<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Solves a linear diophantine equation of the form: &lt;code>ax + by = c&lt;/code>
 *
 * @param {number} a Coefficient for &lt;code>x&lt;/code>
 * @param {number} b Coefficient for &lt;code>y&lt;/code>
 * @param {number} c Right-side constant
 *
 * @returns {Result} One object with all the result values.
 */

const dioSolve = (a, b, c) => {
  // ax + by = c

  const defaultReturn = { z: null, m: null, p: null, g: null, solutionType: 'error' }

  const swap = b > a
  if (swap) [a, b] = [b, a]

  const signs = [Math.sign(a), Math.sign(b)]
  ;[a, b] = [Math.abs(a), Math.abs(b)]

  const steps = []
  const g = gcd(a, b, steps)

  if (g === 0 &amp;&amp; c === 0) return { ...defaultReturn, g, solutionType: 'always-true' }

  if ((c / g) % 1 !== 0) return { ...defaultReturn, g, solutionType: 'none' }

  if (a === 0 || b === 0) {
    const i = Number((a === 0) ^ swap)
    let z = [0, 0]
    z[i] = c / g
    return { ...defaultReturn, z, g, solutionType: 'unique' }
  }

  // Normalize equation
  ;[a, b, c] = [a / g, b / g, c / g]

  // Get quotients from gcd calculation steps
  const q = steps.map(([a, b]) => Math.floor(a / b)).reverse()

  let Ai1 = 0
  let Ai0 = 1

  for (let i = 1; i &lt; q.length; i++) {
    ;[Ai0, Ai1] = [Ai0 * q[i] + Ai1, Ai0]
  }

  const sign = (-1) ** q.length
  let [y0, x0] = [Ai0 * -sign * signs[1], Ai1 * sign * signs[0]]
  let mx = signs[0] * b
  let my = -signs[1] * a

  if (swap) [mx, my, x0, y0] = [my, mx, y0, x0]

  // Coefficients
  const m = [mx, my]

  // Scale solution back to c
  const z = [x0, y0].map((v) => v * c)

  // Offset x0 and y0 to be of the same sign as the m-coefficients
  const n = [0, 1].map((i) => Math.floor(z[i] / m[i]))
  const addN = n[Number(Math.abs(n[1]) > Math.abs(n[0]))]
  const p = [0, 1].map((i) => z[i] - addN * m[i])

  return {
    z,
    m,
    p,
    g,
    solutionType: 'linear',
  }
}

const gcd = (a, b, steps = []) => {
  if (a === 0) return b
  if (b === 0) return a
  const r = a % b
  steps.push([a, b])
  if (r === 0) return Math.abs(b)
  return gcd(b, r, steps)
}

/**
 * @typedef {Object} Result
 * @property {SolutionType} solutionType Type of solution found, see &lt;code>{@link SolutionType}&lt;/code> for more information.
 * @property {number|null} g Value of &lt;code>GCD(a,b)&lt;/code>, &lt;code>null&lt;/code> if error.
 * @property {(Array|number|null)} z Initial solution &lt;code>[x0, y0]&lt;/code> found using the Euclidean algorithm when solution is linear, single number when solution is unique, else &lt;code>null&lt;/code>.
 * @property {Array|null} m Slope coefficients &lt;code>[mx, my]&lt;/code> when solution is linear, else &lt;code>null&lt;/code>.
 * @property {Array|null} p Intercepts &lt;code>[px, py]&lt;/code> when solution is linear, else &lt;code>null&lt;/code>.
 */

/**
 * Enum for solution type values.
 * @readonly
 * @enum {string}
 */

const SolutionType = {
  /** &lt;code>'linear'&lt;/code> – Solutions are &lt;code>x = mx n + px&lt;/code>, &lt;code>y = my n + py&lt;/code>. */
  Linear: 'linear',
  /** &lt;code>'unique'&lt;/code> – When &lt;code>a&lt;/code> or &lt;code>b&lt;/code> is &lt;code>0&lt;/code>, if a solution exists it's unique, e.g. &lt;code>5x + 0y = 15 =>&lt;/code> solution is &lt;code>x = 3&lt;/code>. */
  Unique: 'unique',
  /** &lt;code>'always-true'&lt;/code> – Values of &lt;code>x&lt;/code> and &lt;code>y&lt;/code> don't matter, e.g. &lt;code>0x + 0y = 0&lt;/code>. */
  AlwaysTrue: 'always-true',
  /** &lt;code>'none'&lt;/code> – No solution, e.g. &lt;code>8x + 6y = 1&lt;/code>. */
  None: 'none',
  /** &lt;code>'error'&lt;/code> – Something went wrong. */
  Error: 'error',
}

module.exports = { dioSolve, SolutionType }
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#dioSolve">dioSolve</a></li><li><a href="global.html#SolutionType">SolutionType</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Sat Apr 24 2021 04:27:55 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
